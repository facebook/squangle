/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree.
 */

//
// Operation objects are the handles users of AsyncMysqlClient use to
// interact with connections and queries.  Every action a user
// initiates returns an Operation to track the status of the action,
// report errors, etc.  Operations also offer a way to set callbacks
// for completion.
//
// In general, operations are held in shared_ptr's as ownership is
// unclear.  This allows the construction of Operations, callbacks to
// be set, and the Operation itself be cleaned up by AsyncMysqlClient.
// Conversely, if callbacks aren't being used, the Operation can
// simply be wait()'d upon for completion.
//
// See README for examples.
//
// Implementation detail; Operations straddle the caller's thread and
// the thread managed by the AsyncMysqlClient.  They also are
// responsible for execution of the actual libmysqlclient functions
// and most interactions with libevent.
//
// As mentioned above, an Operation's lifetime is determined by both
// AsyncMysqlClient and the calling point that created an Operation.
// It is permissible to immediately discard an Operation or to hold
// onto it (via a shared_ptr).  However, all calls to methods such as
// result() etc must occur either in the callback or after wait() has
// returned.

#pragma once

#include <folly/Function.h>
#include <folly/concurrency/AtomicSharedPtr.h>
#include <folly/futures/Future.h>
#include <folly/stop_watch.h>
#include <functional>
#include <memory>
#include <string>
#include <variant>

#include "squangle/mysql_client/DbResult.h"
#include "squangle/mysql_client/Flags.h"

namespace facebook::common::mysql_client {

class MysqlClientBase;
class ConnectOperation;
class QueryOperation;
class Operation;

enum class QueryCallbackReason;

// Simplify some std::chrono types.
using Clock = std::chrono::steady_clock;
using Timepoint = std::chrono::time_point<Clock>;

// Callbacks for connecting and querying, respectively.  A
// ConnectCallback is invoked when a connection succeeds or fails.  A
// QueryCallback is called for each row block (see Row.h) as well as
// when the query completes (either successfully or with an error).
using ConnectCallback = std::function<void(ConnectOperation&)>;
// Callback for observer. I will be called for a completed operation,
// after the callback for the specific operation is called, if one is defined.
using ObserverCallback = std::function<void(Operation&)>;
// Callback that is set on the ConnectOperation, and is then chained along all
// subsequent queries on that given connection.
using ChainedCallback = folly::Function<void(Operation&)>;
// Variant type allowing AsyncPostQueryCallback (below) to operate on either a
// Query or MultiQuery result.
using AsyncPostQueryResult = std::variant<DbQueryResult, DbMultiQueryResult>;
// Callbacks that are set on the ConnectOperation, and are then chained along
// all subsequent queries on that given connection. They execute asynchronously
// before/after query operations (if the async query APIs are used), and allow
// modification of the operation before or processing of results after a query.
using AsyncPreQueryCallback =
    std::function<folly::SemiFuture<folly::Unit>(FetchOperation&)>;
using AsyncPostQueryCallback =
    std::function<folly::SemiFuture<AsyncPostQueryResult>(
        AsyncPostQueryResult&&)>;

enum class SquangleErrno : uint16_t {
  SQ_ERRNO_CONN_TIMEOUT = 7000,
  SQ_ERRNO_CONN_TIMEOUT_LOOP_STALLED = 7001,
  SQ_ERRNO_QUERY_TIMEOUT = 7002,
  SQ_ERRNO_QUERY_TIMEOUT_LOOP_STALLED = 7003,
  SQ_ERRNO_POOL_CONN_TIMEOUT = 7004,
  SQ_ERRNO_FAILED_CONFIG_INIT = 7005,
  SQ_INVALID_API_USAGE = 7006,
  SQ_INITIALIZATION_FAILED = 7007,
  SQ_INVALID_CONN = 7008,
};

// prefix to use in mysql errors generated by the client
constexpr auto kErrorPrefix = "MySQL Client";

// The state of the Operation.  In general, callers will see Unstarted
// (i.e., haven't yet called run()) or Completed (which may mean
// success or error; see OperationResult below).  Pending and
// Cancelling are not visible at times an outside caller might see
// them (since, once run() has been called, wait() must be called
// before inspecting other Operation attributes).
enum class OperationState {
  Unstarted,
  Pending,
  Cancelling,
  Completed,
};

// overload of operator<< for OperationState
std::ostream& operator<<(std::ostream& os, OperationState state);

// Once an operation is Completed, it has a result type, indicating
// what ultimately occurred.  These are self-explanatory.
enum class OperationResult {
  Unknown,
  Succeeded,
  Failed,
  Cancelled,
  TimedOut,
};

// overload of operator<< for OperationResult
std::ostream& operator<<(std::ostream& os, OperationResult result);

enum class StreamState { InitQuery, RowsReady, QueryEnded, Failure, Success };

// overload of operator<< for StreamState
std::ostream& operator<<(std::ostream& os, StreamState state);

//  Public facing Operation API
class Operation : public std::enable_shared_from_this<Operation> {
 protected:
  class ConnectionProxy;

  explicit Operation(std::unique_ptr<ConnectionProxy> safe_conn)
      : conn_proxy_(std::move(safe_conn)) {
    timeout_ = Duration(FLAGS_async_mysql_timeout_micros);
    request_context_.store(
        folly::RequestContext::saveContext(), std::memory_order_relaxed);
  }

 public:
  virtual ~Operation() = default;

  // No default constructor or copy constructor/assignment operators
  Operation() = delete;
  Operation(const Operation&) = delete;
  Operation& operator=(const Operation&) = delete;

  Operation& run();

  // Try to cancel a pending operation.  This is inherently racey with
  // callbacks; it is possible the callback is being invoked *during*
  // the cancel attempt, so a cancelled operation may still succeed.
  void cancel();

  virtual void wait() const = 0;

  // Did the operation succeed?
  bool ok() const {
    return done() && result() == OperationResult::Succeeded;
  }

  // Is the operation complete (success or failure)?
  bool done() const {
    return state() == OperationState::Completed;
  }

  // Wait for an operation to complete.  Throw a
  // RequiredOperationFailedException if it fails. Mainly for testing.
  virtual void mustSucceed() = 0;

  virtual unsigned int mysql_errno() const = 0;
  virtual const std::string& mysql_error() const = 0;

  OperationResult result() const {
    return result_;
  }

  OperationState state() const {
    return state_;
  }

  virtual void setObserverCallback(ObserverCallback obs_cb) = 0;

  Operation& setAttributes(const AttributeMap& attributes);
  Operation& setAttributes(AttributeMap&& attributes);
  Operation& setAttribute(const std::string& key, const std::string& value);

  const AttributeMap& getAttributes() const {
    return attributes_;
  }

  // Set a timeout; otherwise FLAGS_async_mysql_timeout_micros is
  // used.
  Operation& setTimeout(Duration timeout);

  Duration getTimeout() const {
    return timeout_;
  }

  Millis getTimeoutMs() const {
    return std::chrono::duration_cast<Millis>(timeout_);
  }

  virtual db::OperationType getOperationType() const = 0;

  // Retrieve the shared pointer that holds this instance.
  std::shared_ptr<Operation> getSharedPointer();

  static folly::StringPiece toString(OperationState state);
  static folly::StringPiece toString(OperationResult result);
  static folly::StringPiece toString(StreamState state);

  folly::StringPiece resultString() const;
  folly::StringPiece stateString() const;

  // Connections are transferred across operations.  At any one time,
  // there is one unique owner of the connection.
  std::unique_ptr<Connection> releaseConnection();
  const Connection* connection() const {
    return conn_proxy_->get();
  }
  Connection* connection() {
    return conn_proxy_->get();
  }

  /*
   * Various accessors for our Operation's start, end, and total elapsed time.
   */

  // Start time of the operation (doesn't need to have completed)
  Timepoint startTime() const {
    return stopwatch_->getCheckpoint();
  }
  // End time of the operation (must have completed)
  Timepoint endTime() const {
    CHECK_THROW(
        state() == OperationState::Completed, db::OperationStateException);
    return startTime() + duration_;
  }
  // Current stored time elapsed
  Duration elapsed() const {
    CHECK_THROW(duration_ != Duration(), db::OperationStateException);
    return duration_;
  }

  // Current time elapsed
  Duration opElapsed() const {
    return stopwatch_->elapsed();
  }
  // Current time elapsed in milliseconds
  Millis opElapsedMs() const {
    return std::chrono::duration_cast<Millis>(opElapsed());
  }
  // Has a particular time period elapsed
  bool hasOpElapsed(Duration timeperiod) const {
    return stopwatch_->elapsed(timeperiod);
  }

  /**
   * Set various callbacks that are invoked during the operation's lifetime
   * The pre and post operations are chained, in that they are propagated to
   * operations that are scheduled on the connection following the current
   * operation. A couple notes:
   *
   * The PreOperationCallback will be invoked on a cancelled operation before
   * the cancellation takes effect
   *
   * The PostOperationCallback will be invoked on operations that have failed
   */
  void setPreOperationCallback(ChainedCallback obs_cb);
  void setPostOperationCallback(ChainedCallback obs_cb);

 protected:
  class ConnectionProxy {
   public:
    virtual ~ConnectionProxy() = default;

    virtual Connection* get() = 0;
    virtual const Connection* get() const = 0;
    virtual std::unique_ptr<Connection> releaseConnection() {
      return nullptr;
    }
  };

  // An owned connection is one where the operation fully owns the connection.
  // This occurs when a query is started via a semi-future and the connection is
  // moved in - for example:
  //   client->querySemiFuture(std::move(conn), "SELECT 1");
  // Since the connection is a unique_ptr, moving it in this way means that we
  // have full control over it.
  class OwnedConnection : public ConnectionProxy {
   public:
    explicit OwnedConnection(std::unique_ptr<Connection>&& conn);

    Connection* get() override;
    const Connection* get() const override;
    std::unique_ptr<Connection> releaseConnection() override;

   private:
    std::unique_ptr<Connection> conn_;
  };

  // A referenced connection is one where the operation can only have a
  // reference to the connection. This occurs when a query is started via the
  // connection itself and the query function doesn't return control back until
  // the query is complete - for example:
  //   conn->query("SELECT 1");
  // In this case the connection is still owned by the caller so the most we can
  // have is a reference to it.
  class ReferencedConnection : public ConnectionProxy {
   public:
    explicit ReferencedConnection(Connection& conn) : conn_(conn) {}

    Connection* get() override {
      return &conn_;
    }
    const Connection* get() const override {
      return &conn_;
    }

   private:
    Connection& conn_;
  };

  void setState(OperationState state) {
    state_ = state;
  }
  void setResult(OperationResult result) {
    result_ = result;
  }
  void setDuration() {
    duration_ = opElapsed();
  }

  void setTimeoutInternal(Duration timeout) {
    timeout_ = timeout;
  }

  folly::RequestContextScopeGuard makeRequestGuard() {
    return folly::RequestContextScopeGuard(
        request_context_.load(std::memory_order_relaxed));
  }

  // Helper function to set chained callbacks
  ChainedCallback setCallback(
      ChainedCallback orgCallback,
      ChainedCallback newCallback);

  // Our Connection object.  Created by ConnectOperation and moved
  // into QueryOperations.
  std::unique_ptr<ConnectionProxy> conn_proxy_;

  struct Callbacks {
    Callbacks()
        : pre_operation_callback_(nullptr),
          post_operation_callback_(nullptr),
          pre_query_callback_(nullptr),
          post_query_callback_(nullptr) {}

    ChainedCallback pre_operation_callback_;
    ChainedCallback post_operation_callback_;

    AsyncPreQueryCallback pre_query_callback_;
    AsyncPostQueryCallback post_query_callback_;
  };

  Callbacks callbacks_;

  virtual Operation& specializedRun() = 0;
  virtual void protocolCompleteOperation(OperationResult result) = 0;

 private:
  // Data members; subclasses freely interact with these.
  OperationState state_{OperationState::Unstarted};
  OperationResult result_{OperationResult::Unknown};

  // Connection or query attributes (depending on the Operation type)
  AttributeMap attributes_;

  // timeout specified for this operation
  Duration timeout_;

  using StopWatch = folly::stop_watch<Duration>;
  std::unique_ptr<StopWatch> stopwatch_;
  Duration duration_ = Duration();

  // The cancel() and run() commands both check the current value of state_ and
  // then change it.  The synchronized state on `cancel_on_run_` is used to
  // protect this check and then set code.  This is not an ideal solution, but
  // we don't really need to synchronize state_ anywhere else, so putting it in
  // a Synchronized<> object is overkill.
  folly::Synchronized<bool> cancel_on_run_{false};

  folly::atomic_shared_ptr<folly::RequestContext> request_context_;
};

// The abstract base for our available Operations.  Subclasses share
// intimate knowledge with the Operation class (most member variables
// are protected).
class OperationImpl : public Operation,
                      public folly::EventHandler,
                      public folly::AsyncTimeout {
 public:
  // No public constructor.
  virtual ~OperationImpl() override = default;

  OperationImpl() = delete;
  OperationImpl(const OperationImpl&) = delete;
  OperationImpl& operator=(const OperationImpl&) = delete;

  Duration getMaxThreadBlockTime() {
    return max_thread_block_time_;
  }

  Duration getTotalThreadBlockTime() {
    return total_thread_block_time_;
  }

  void logThreadBlockTime(const folly::stop_watch<Duration> sw) {
    auto block_time = sw.elapsed();
    max_thread_block_time_ = std::max(max_thread_block_time_, block_time);
    total_thread_block_time_ += block_time;
  }

  // host and port we are connected to (or will be connected to).
  const std::string& host() const;
  int port() const;

  // Wait for the Operation to complete.
  void wait() const override;

  // Information about why this operation failed.
  unsigned int mysql_errno() const override {
    return mysql_errno_;
  }
  const std::string& mysql_error() const override {
    return mysql_error_;
  }

  static std::string connectStageString(connect_stage stage);

  void setObserverCallback(ObserverCallback obs_cb) override;

  /**
   * Set callbacks that are invoked asynchronously before/after query operations
   * (if using asynchronous query APIs). They do not execute on operations that
   * have failed, and if they fail the operation will fail too.
   *
   * PreQueryCallbacks execute after a query operation is initialized and before
   * it has been run. They are allowed to modify the operation by reference.
   *
   * PostQueryCallbacks execute after a query operation returns results. They
   * are allowed to do post-processing on the results received and returned via
   * rvalue reference.
   */
  void setPreQueryCallback(AsyncPreQueryCallback&& callback);
  void setPostQueryCallback(AsyncPostQueryCallback&& callback);

  MysqlClientBase& client() const;

  void setAsyncClientError(unsigned int mysql_errno, folly::StringPiece msg);

 protected:
  // Helper functions to set query callbacks
  static AsyncPreQueryCallback appendCallback(
      AsyncPreQueryCallback&& callback1,
      AsyncPreQueryCallback&& callback2);

  static AsyncPostQueryCallback appendCallback(
      AsyncPostQueryCallback&& callback1,
      AsyncPostQueryCallback&& callback2);

  static constexpr double kCallbackDelayStallThresholdUs = 50 * 1000;

  explicit OperationImpl(std::unique_ptr<ConnectionProxy> conn);

  Connection& conn() {
    auto* conn = connection();
    CHECK(conn);
    return *conn;
  }
  const Connection& conn() const {
    const auto* conn = connection();
    CHECK(conn);
    return *conn;
  }

  // Save any mysql errors that occurred (since we may hand off the
  // Connection before the user wants this information).
  void snapshotMysqlErrors();

  // Called when an Operation needs to wait for the data to be readable or
  // writable (aka actionable).
  void waitForActionable();

  // Overridden in child classes and invoked when the status is actionable. This
  // function should either completeOperation or waitForActionable.
  virtual void actionable() = 0;

  // EventHandler override
  void handlerReady(uint16_t /*events*/) noexcept override;

  // AsyncTimeout override
  void timeoutExpired() noexcept override {
    timeoutTriggered();
  }

  // Called by AsyncTimeout::timeoutExpired when the operation timed out
  void timeoutTriggered();

  // Our operation has completed.  During completeOperation,
  // specializedCompleteOperation is invoked for subclasses to perform
  // their own finalization (typically annotating errors and handling
  // timeouts).
  void completeOperation(OperationResult result);
  void completeOperationInner(OperationResult result);
  virtual void specializedTimeoutTriggered() = 0;
  virtual void specializedCompleteOperation() = 0;

  void protocolCompleteOperation(OperationResult result) override;

  bool isInEventBaseThread() const;
  bool isEventBaseSet() const;

  std::string threadOverloadMessage(double cbDelayUs) const;
  std::string timeoutMessage(Millis delta) const;

  // This will contain the max block time of the thread
  Duration max_thread_block_time_ = Duration(0);
  Duration total_thread_block_time_ = Duration(0);

  // Errors that may have occurred.
  unsigned int mysql_errno_;
  std::string mysql_error_;

  // Friends because they need to access the query callbacks on this class
  template <typename Operation>
  friend folly::SemiFuture<folly::Unit> handlePreQueryCallback(Operation& op);
  template <typename ReturnType, typename Operation, typename QueryResult>
  friend void handleQueryCompletion(
      Operation& op,
      QueryResult query_result,
      QueryCallbackReason reason,
      folly::Promise<std::pair<ReturnType, AsyncPostQueryCallback>>& promise);

 private:
  // Restore folly::RequestContext and also invoke actionable()
  void invokeActionable();

  ObserverCallback observer_callback_;
  std::shared_ptr<db::ConnectionContextBase> connection_context_;

  MysqlClientBase& mysql_client_;

  friend class Connection;
  friend class SyncConnection;
  friend class SyncConnectionPool;
};

// Helper function to build the result for a ConnectOperation in the sync
// mode. It will block the thread and return the acquired connection, in case
// of error, it will throw MysqlException as expected in the sync mode.
std::unique_ptr<Connection> blockingConnectHelper(
    std::shared_ptr<ConnectOperation> conn_op);

} // namespace facebook::common::mysql_client
